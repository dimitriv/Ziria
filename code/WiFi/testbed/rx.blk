#define LTS_ACCURATE
#define RADIO
#define DO_DECODING
-- #define FAST


-- TODO: these should be declared in cntRxPkts but currently there is a bug
-- that resets it in every round in cntRxPkts, even though it shouldn't
-- Once the bug is fixed, this should be put back there.
var cnt : int := 0;
var lastPkt : int8 := -1;
var received : int := 0;
var errors : int := 0;
var missed : int := 0;



#include <externals.blk>
#include "../const.blk"
#include "../receiver/cca/cca_tufv.blk"
#include "../receiver/OFDM/LTS.blk"
#include "../receiver/removeDC.blk"
#include "../receiver/downSample.blk"
#include "../receiver/OFDM/DataSymbol.blk"
#include "../receiver/OFDM/FreqCompensation.blk"
#include "../receiver/OFDM/FFT.blk"
#include "../receiver/OFDM/ChannelEqualization.blk"
#include "../receiver/OFDM/PilotTrack.blk"
#include "../receiver/OFDM/GetData.blk"

#ifdef DO_DECODING
#include "../receiver/decoding/DecodePLCP.blk"
#include "../receiver/decoding/Decode.blk"
#include "../transmitter/crc.blk"
#endif






let comp detectPreamble() = 
  (removeDC() >>> cca())
in 



#ifdef DO_DECODING
-- Extract pktID from the payload and check CRC
-- TODO: There is a bug here! The following won't work:
-- let comp [8, 1] getPktIdAndCheckCRC (len : int) =  
let comp getPktIdAndCheckCRC (len : int) =  
var crc_state: arr[4] bit := {'0,'0,'0,'0};
var arrInt : arr[1] int8; 
var pktNo : int8 := 0;
var byteCnt : int := 0;
  times len seq {
    (x:arr[8] bit) <- takes 8;
    do {
      -- Check the payload for pkt count
      if (byteCnt == 0) then
      { 
         bits_to_int8(arrInt, x);
         pktNo := arrInt[0];
      }
      if (byteCnt > 0 && byteCnt < 16) then {
         bits_to_int8(arrInt, x);
         if (pktNo == -1 || pktNo != arrInt[0]) then {
           pktNo := -1;
         }
      }
      byteCnt := byteCnt + 1;

      -- Update CRC
      for i in [0, 8] {
        update_crc(x[i], crc_state)
      }
    }
    --emits x;
  };

  crcOK <- check_crc(crc_state);

  do {
    if (not crcOK) then pktNo := -1;
  }

  emit pktNo;
in


let comp receiveBits() = 
  { hdata <- DecodePLCP()
  ; Decode(hdata) >>> getPktIdAndCheckCRC(hdata.len)
  }
in


let comp cntRxPkts() =
-- TODO: See the top of the file for explanation
-- var cnt : int := 0;
-- var lastPkt : int8 := -1;
-- var received : int := 0;
-- var errors : int := 0;
-- var missed : int := 0;

repeat {
  x <- take;
  do{
    if (lastPkt == -1) then {
      -- Starting counting
      lastPkt := x;
      if (x == -1) then {
        errors := errors + 1;
      } else {
        received := received + 1;
      }
    } else {
      if (x == -1) then { 
        -- Packet error detected
        errors := errors + 1;
        lastPkt := lastPkt + 1;
      } else {
        -- Some packets missed in the counter
        if (x - lastPkt > 1) then {
          missed := missed + int(x - lastPkt - 1);
        } else {
          received := received + 1;
        }
        lastPkt := x;
      }
    }
#ifndef FAST
    print_time();
    println " Received: ", received, " Errors: ", errors, " Missed: ", missed;
#else
    if (cnt == 100) then {
      print_time();
      println " Received: ", received, " Errors: ", errors, " Missed: ", missed;
      cnt := 0;
    }
#endif
    cnt := cnt + 1;
  }
}
in
#endif





let comp skip() = 
  -- times 1 {
  times 65000 {
     x<- take;
  }

  repeat {
    x<- take;
    emit x;
  }  
in



{-
read[complex16] >>> 
  skip() >>>
#ifndef RADIO
  downSample() >>> 
#endif
  {det <- detectPreamble();
    times 10000 {x<-take; emit x}
  }
>>> write
-}



read >>> 
--  skip() >>>
#ifndef RADIO
  downSample() >>> 
#endif
  repeat {
    seq{ det<-detectPreamble()
#ifndef FAST
       ; do{println "Detected at: ", det.noSamples}
#endif
       ; params <- (LTS(det.shift)); 
         DataSymbol(det.shift) 
         >>> FFT() 
         >>> ChannelEqualization(params)
         >>> PilotTrack() 
         >>> GetData()
#ifdef DO_DECODING
         >>> receiveBits()
#endif
    }
  }
#ifdef DO_DECODING
  >>> cntRxPkts()
>>> write[int]
#else
>>> write
#endif

